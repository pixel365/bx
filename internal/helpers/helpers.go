package helpers

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"iter"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/charmbracelet/huh/spinner"

	"github.com/pixel365/bx/internal/interfaces"

	"github.com/pixel365/bx/internal/errors"

	"github.com/pixel365/bx/internal/types"

	"github.com/charmbracelet/huh"

	"golang.org/x/mod/semver"
)

type Cfg string

const RootDir Cfg = "root_dir"

// Choose displays a selection prompt to the user and stores the chosen value.
//
// If the list contains exactly one non-empty item, it is selected automatically without prompting.
// Otherwise, a selection menu is rendered using the `huh` library. The chosen item is stored in the provided `value`
// pointer.
//
// Parameters:
//   - items: A pointer to a slice of strings representing selectable items. Must not be nil or empty.
//   - value: A pointer to a string where the selected item will be stored.
//   - title: The title of the selection prompt shown to the user.
//
// Returns:
//   - error: An error if the item list is empty, contains an empty item, or if the selection prompt fails to run.
//
// Notes:
//   - If any item in the list is an empty string, an error is returned.
//   - The function returns `errors.ErrNoItems` when `items` is nil or has zero length.
func Choose(items *[]string, value *string, title string) error {
	if items == nil || len(*items) == 0 {
		return errors.ErrNoItems
	}

	n := len(*items)
	if n == 1 && (*items)[0] != "" {
		*value = (*items)[0]
		return nil
	}

	options := make([]huh.Option[string], n)
	for i, item := range *items {
		if item == "" {
			return fmt.Errorf("empty item at index %d", i)
		}

		options[i] = huh.NewOption(item, item)
	}

	return huh.NewSelect[string]().
		Title(title).
		Options(options...).
		Value(value).
		Run()
}

// CaptureOutput captures and returns the standard output (stdout) generated by the execution of the provided function.
//
// It temporarily redirects os.Stdout to a pipe, executes the given function `f`,
// and then restores the original os.Stdout. All data written to stdout during the function's execution
// is captured and returned as a string.
//
// Parameters:
//   - f: A function with no parameters and no return value whose stdout output will be captured.
//
// Returns:
//   - string: The content written to stdout during the execution of `f`.
//     Returns an empty string if an error occurs during pipe handling.
//
// Note: Any error from pipe creation or reading is silently ignored.
// This function is not safe for concurrent use of os.Stdout.
func CaptureOutput(f func()) string {
	r, w, _ := os.Pipe()
	stdout := os.Stdout
	os.Stdout = w

	f()

	err := w.Close()
	if err != nil {
		return ""
	}

	os.Stdout = stdout
	var buf bytes.Buffer
	_, _ = buf.ReadFrom(r)

	return buf.String()
}

// ResultMessage prints a formatted message to standard output.
//
// If no additional arguments are provided, the format string is printed as-is
// using fmt.Println. If arguments are provided, the function formats the string
// using fmt.Printf.
//
// Parameters:
//   - format: The string to print, which may include format verbs if arguments are supplied.
//   - a: Optional variadic arguments to be used with format verbs in the format string.
func ResultMessage(format string, a ...any) {
	if len(a) == 0 {
		fmt.Println(format)
	} else {
		fmt.Printf(format, a...)
	}
}

// GetModulesDir returns the absolute path to the `.bx` directory located in the current working directory.
//
// It attempts to retrieve the current working directory using os.Getwd() and constructs
// the path to a `.bx` subdirectory. The result is then converted to an absolute path.
//
// Returns:
//   - string: The absolute path to the `.bx` directory.
//   - error: An error if the path resolution fails.
//
// Note: Any error returned by os.Getwd is silently ignored, which may lead to unexpected behavior.
func GetModulesDir() (string, error) {
	dirPath, _ := os.Getwd()
	return filepath.Abs(fmt.Sprintf("%s/.bx", dirPath))
}

func DefaultYAML() string {
	return `name: "test"
version: "1.0.0"
account: ""
buildDirectory: "./dist/test"
logDirectory: "./logs/test"

variables:
  structPath: "./examples/structure"
  install: "install"
  bitrix: "{structPath}/bitrix"
  local: "{structPath}/local"

stages:
  - name: "components"
    to: "{install}/components"
    actionIfFileExists: "replace"
    from:
      - "{bitrix}/components"
      - "{local}/components"
  - name: "templates"
    to: "{install}/templates"
    actionIfFileExists: "replace"
    from:
      - "{bitrix}/templates"
      - "{local}/templates"
  - name: "rootFiles"
    to: "."
    actionIfFileExists: "replace"
    from:
      - "{structPath}/simple-file.php"
  - name: "testFiles"
    to: "test"
    actionIfFileExists: "replace"
    from:
      - "{structPath}/simple-file.php"
    convertTo1251: false

builds:
  release:
    - "components"
    - "templates"
    - "rootFiles"
    - "testFiles"
  lastVersion:
    - "components"
    - "templates"
    - "rootFiles"
    - "testFiles"

ignore:
  - "**/*.log"
`
}

// CheckPath checks if a given path is valid and exists on the filesystem.
//
// This function cleans the provided path and verifies its validity using the `IsValidPath` function.
// It then checks if the file or directory exists using `os.Stat`.
// If the file or directory does not exist or is not valid, an appropriate error is returned.
//
// Parameters:
//   - path (string): The path to be validated and checked for existence.
//
// Returns:
//   - error: An error if the path is invalid or does not exist, otherwise returns nil.
func CheckPath(path string) error {
	path = filepath.Clean(path)
	if !IsValidPath(path, path) {
		return errors.ErrInvalidFilepath
	}

	_, err := os.Stat(path)
	if err != nil {
		return err
	}

	return nil
}

// IsDir checks if the given path points to a directory.
//
// This function first checks if the path is valid using the `CheckPath` function.
// Then, it retrieves the file information using `os.Stat` to determine whether the
// given path is a directory or not.
//
// Parameters:
//   - path (string): The path to be checked.
//
// Returns:
//   - bool: `true` if the path is a directory, `false` otherwise.
//   - error: An error if the path is invalid or if there is an issue retrieving the file information.
func IsDir(path string) (bool, error) {
	err := CheckPath(path)
	if err != nil {
		return false, err
	}
	fi, _ := os.Stat(path)

	return fi.Mode().IsDir(), nil
}

// CheckContext checks whether the provided context has been canceled or expired.
//
// This function checks if the context has been canceled or the deadline exceeded.
// If the context is done, it returns an error indicating the cancellation or expiration.
// If the context is still active, it returns nil.
//
// Parameters:
//   - ctx (context.Context): The context to check.
//
// Returns:
//   - error: Returns an error if the context is done (canceled or expired), otherwise nil.
func CheckContext(ctx context.Context) error {
	if ctx == nil {
		return errors.ErrNilContext
	}

	select {
	case <-ctx.Done():
		return fmt.Errorf("context canceled: %w", ctx.Err())
	default:
		return nil
	}
}

// CheckPaths checks whether the paths in the "From" field of a stage are valid.
//
// This function iterates over the paths in the "From" field of the given stage and checks
// if each path is valid by calling the CheckPath function. If any path is invalid,
// it sends the error to the provided channel and exits early.
//
// Parameters:
//   - stage (Stage): The stage containing the "From" paths to check.
//   - ch (chan<- error): A channel to send any errors encountered during the path checks.
//
// The function does not return any value. If an error occurs during path validation,
// the error is sent to the provided channel.
func CheckPaths(stage types.Stage, ch chan<- error) {
	for _, path := range stage.From {
		err := CheckPath(path)
		if err != nil {
			ch <- err
		}
	}
}

// IsValidPath checks if the given filePath is a valid path relative to the basePath.
//
// This function determines whether the absolute path of filePath is within the
// directory specified by basePath. It ensures that the file path does not contain
// any ".." segments, which would indicate an attempt to traverse up the directory
// structure, and that the filePath is within the basePath directory.
//
// Parameters:
//   - filePath (string): The path to check for validity.
//   - basePath (string): The base directory to check against.
//
// Returns:
//   - bool: Returns true if the filePath is valid (i.e., is within the basePath directory),
//     otherwise returns false.
func IsValidPath(filePath, basePath string) bool {
	absBasePath, _ := filepath.Abs(basePath)
	absFilePath, _ := filepath.Abs(filePath)

	return strings.HasPrefix(absFilePath, absBasePath)
}

// ReplaceVariables recursively replaces variables in the input string with
// their corresponding values from the provided map of variables.
//
// The function supports up to 5 levels of recursion (controlled by the `depth`
// parameter) to allow nested variable replacements. If the depth exceeds 5 or
// if the depth is less than 0, an error will be returned.
//
// Parameters:
//   - input (string): The input string containing variables in the format `{variableName}` to replace.
//   - variables (map[string]string): A map containing variable names as keys and their replacement values as strings.
//   - depth (int): The current recursion depth, which should start from 0. The function supports up to 5 levels of
//     recursion.
//
// Returns:
//   - string: The updated string with variables replaced by their corresponding values, or an error if no replacement
//     could be made.
//   - error: An error is returned if the depth exceeds 5, if the depth is negative, or if the replacement results in
//     an empty string.
func ReplaceVariables(input string, variables map[string]string, depth int) (string, error) {
	if depth < 0 {
		return "", errors.ErrSmallDepth
	}

	if depth > 5 {
		return "", errors.ErrLargeDepth
	}

	variableRegex := regexp.MustCompile(`\{([a-zA-Z0-9-_]+)}`)
	updated := variableRegex.ReplaceAllStringFunc(input, func(match string) string {
		key := strings.Trim(match, "{}")
		if value, ok := variables[key]; ok {
			return value
		}

		return ""
	})

	if updated == "" {
		return "", errors.ErrReplacement
	}

	if updated == input {
		return updated, nil
	}

	return ReplaceVariables(updated, variables, depth+1)
}

// Cleanup closes the provided resource and handles any errors that occur during closure.
//
// If the resource is nil, the function returns immediately without taking any action.
// If resource is not nil, its Close() method is called.
// If Close() returns an error and the provided
//
// channel ch is not nil, the error is sent to ch.
//
// Parameters:
//   - resource: an object that implements the io.Closer interface, representing the resource to be closed.
//   - ch: a channel for reporting errors.
//     If ch is nil, any errors from resource.Close() are ignored.
func Cleanup(resource io.Closer, ch chan<- error) {
	if resource == nil {
		return
	}

	if err := resource.Close(); err != nil && ch != nil {
		ch <- err
	}
}

// UserInput displays an interactive input prompt with a title and validation,
// using the provided Prompter interface.
//
// The entered value is stored in the
// given string pointer.
// If the input fails validation or an error occurs,
// the function returns an error.
//
// Parameters:
//   - prompter: an implementation of the Prompter interface that handles input rendering and retrieval.
//   - variable: a pointer to a string where the resulting input will be stored.
//   - title: the title or label shown to the user for the input prompt.
//   - validator: a function used to validate the user input.
//
// Returns:
//   - error: an error if the input fails validation or the prompt fails to run; nil on success.
func UserInput(
	prompter interfaces.Prompter,
	variable *string,
	title string,
	validator func(string) error,
) error {
	if err := prompter.Input(title, validator); err != nil {
		return err
	}

	*variable = prompter.GetValue()

	return nil
}

// Spinner displays a terminal spinner with the given title while executing the provided action.
//
// It uses a spinner animation (of type Dots) to indicate that a long-running operation is in progress.
// The spinner stops once the action completes, and any error returned from the action is propagated.
//
// Parameters:
//   - title: A string to display as the spinner's message.
//   - action: A function that takes a context and returns an error. It is executed while the spinner is running.
//
// Returns:
//   - error: The error returned by the action function, if any.
func Spinner(title string, action func(context.Context) error) error {
	return spinner.New().
		Title(title).
		Type(spinner.Dots).
		ActionWithErr(action).
		Run()
}

// SortSemanticVersions sorts a sequence of version strings according to
// semantic versioning rules (https://semver.org).
// Versions that do not start with a 'v' prefix are normalized automatically (e.g., "1.2.3" becomes "v1.2.3").
// The returned slice is a new sorted copy; the input is not modified.
func SortSemanticVersions(versions iter.Seq[string]) []string {
	result := slices.SortedFunc(versions, func(a string, b string) int {
		return semver.Compare(normalizeVersion(a), normalizeVersion(b))
	})

	return result
}

// normalizeVersion ensures that a version string has a 'v' prefix,
// as required by the semver.Compare function.
// If the version already starts with 'v', it is returned unchanged.
func normalizeVersion(version string) string {
	if !strings.HasPrefix(version, "v") {
		return "v" + version
	}
	return version
}
